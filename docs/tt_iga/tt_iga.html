<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tt_iga.tt_iga API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tt_iga.tt_iga</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import torch as tn
import torchtt as tntt
import numpy as np
from ._aux_functions import *
import matplotlib.pyplot as plt
import datetime


class Function():
      
    def __init__(self, basis):
        &#34;&#34;&#34;
        

        Args:
            basis ([type]): [description]
        &#34;&#34;&#34;
        self.N = [b.N for b in basis]
        self.basis = basis
        
    def interpolate(self, function, geometry = None, eps = 1e-12):
        &#34;&#34;&#34;
        

        Args:
            function ([type]): [description]
            geometry ([type], optional): [description]. Defaults to None.
            eps ([type], optional): [description]. Defaults to 1e-12.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
        Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
        
        corz = [tn.reshape(Mg[i].t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
        Gm = tntt.TT(corz)
        
        if geometry == None:
            X = tntt.TT(Xg[0])**tntt.ones(self.N[1:])   
            Y = tntt.ones(self.N[:1]) ** tntt.TT(Xg[1]) ** tntt.ones(self.N[2:]) 
            Z = tntt.ones(self.N[:2]) ** tntt.TT(Xg[2]) ** tntt.ones(self.N[3:])  
        else:
            X,Y,Z = geometry(Xg)

        if len(self.basis)==3:
            evals = tntt.interpolate.function_interpolate(function, [X, Y, Z], eps)
        else:
            Np = len(self.basis[3:])
            meshgrid = tntt.meshgrid([x for x in Xg[3:]])
            meshgrid = [X,Y,Z] + [tntt.ones([n for n in self.N[:3]])**m for m in meshgrid]
            evals = tntt.interpolate.function_interpolate(function, meshgrid, eps, verbose = False)
            

        dofs = tntt.solvers.amen_solve(Gm,evals,x0 = evals,eps = eps,verbose = False)
        self.dofs = dofs
        
        return dofs
    
    def __call__(self, x, deriv = None):
        &#34;&#34;&#34;
        

        Args:
            x ([type]): [description]
            deriv ([type], optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if deriv == None:
            deriv = [False]*len(self.N)
        
        Bs = [tn.tensor(self.basis[i](x[i].numpy(),derivative=deriv[i]), dtype = tn.float64).t() for i in range(len(self.N))]
        B_tt = tntt.TT([tn.reshape(m,[1,m.shape[0],-1,1]) for m in Bs])
        
        val = B_tt @ self.dofs
        
        return val 
    
    def L2error(self, function, geometry_map = None, level = 32):
        &#34;&#34;&#34;
        

        Args:
            function ([type]): [description]
            geometry_map ([type], optional): [description]. Defaults to None.
            level (int, optional): [description]. Defaults to 32.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        pts, ws = np.polynomial.legendre.leggauss(level)
        pts = (pts+1)*0.5
        ws = ws/2
        
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
         
        if geometry_map != None:
            X,Y,Z = geometry_map([tn.tensor(pts)]*len(self.N))
            Og_tt = geometry_map.eval_omega([tn.tensor(pts)]*3, interp=True)
        else:
            X,Y,Z = geometry_map(Xg)
        
        B_tt = tntt.TT(self.basis[0](pts),shape = [(self.basis[0].N,pts.size)]) ** tntt.TT(self.basis[1](pts),shape = [(self.basis[1].N,pts.size)]) ** tntt.TT(self.basis[2](pts),shape = [(self.basis[2].N,pts.size)]) 
        B_tt = B_tt.t()
        C_tt = tntt.eye(B_tt.M)
        
        for i in range(3,len(self.basis)):
            B_tt = B_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
            C_tt = C_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
        # X = C_tt @ X
        # Y = C_tt @ Y
        # Z = C_tt @ Z
        Og_tt = C_tt @ Og_tt
        d_eval = B_tt @ self.dofs
        
        if len(self.basis)==3:
            f_eval = tntt.interpolate.function_interpolate(function, [X, Y, Z], 1e-13)
        else:
            Np = len(self.N[3:])
            meshgrid = tntt.meshgrid([tn.tensor(pts)]*Np)
            meshgrid = [X,Y,Z] + [tntt.ones([pts.size]*3)**m for m in meshgrid]
            f_eval = tntt.interpolate.function_interpolate(function, meshgrid, 1e-13)
        
        diff = f_eval-d_eval
        Ws = tntt.rank1TT(len(self.basis)*[tn.tensor(ws)])
        
        integral = np.abs(tntt.dot(Ws*diff,diff*Og_tt).numpy())
        # print(integral)
        return np.sqrt(integral)
    
class Geometry():
    
    def __init__(self, basis, Xs = None):
        &#34;&#34;&#34;
        

        Args:
            basis ([type]): [description]
            Xs ([type], optional): [description]. Defaults to None.
        &#34;&#34;&#34;
        self.N = [b.N for b in basis]
        self.basis = basis
        self.Xs = Xs
        
    def interpolate(self, geometry_map, eps = 1e-13):
        &#34;&#34;&#34;
        Interpolates the given geometry map.

        Args:
            geometry_map (list[function]): [description]
            eps ([type], optional): [description]. Defaults to 1e-13.
        &#34;&#34;&#34;
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
        Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
        
        corz = [tn.reshape(tn.linalg.inv(Mg[i]).t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
        Gmi = tntt.TT(corz)
        
        Xs = []
        
        for i in range(3):
            evals = tntt.interpolate.function_interpolate(geometry_map[i], tntt.meshgrid(Xg), eps = eps).round(eps)
            dofs = (Gmi @ evals).round(eps)
            Xs.append(dofs)
            
        self.Xs = Xs
        
    def __call__(self, x, deriv = None):
        
        if deriv == None:
            deriv = [False] * len(self.N)
            
        Bs = [tn.tensor(self.basis[i](x[i].numpy(),derivative=deriv[i]), dtype = tn.float64).t() for i in range(len(self.N))]

        B_tt = tntt.TT([tn.reshape(m,[1,m.shape[0],-1,1]) for m in Bs])
        
        ret = []
        
        for X in self.Xs:
            ret.append(B_tt @ X)
        
        return ret

    def eval_omega(self, x, eps = 1e-12, interp = True):
        
        #evgaluate univariate bsplines and their derivative 
        B1 = tntt.TT(tn.tensor(self.basis[0](x[0]).transpose()), [(x[0].shape[0],self.N[0])])
        dB1 = tntt.TT(tn.tensor(self.basis[0](x[0],derivative=True).transpose()), [(x[0].shape[0],self.N[0])])
        B2 = tntt.TT(tn.tensor(self.basis[1](x[1]).transpose()), [(x[1].shape[0],self.N[1])])
        dB2 = tntt.TT(tn.tensor(self.basis[1](x[1],derivative=True).transpose()), [(x[1].shape[0],self.N[1])])
        B3 = tntt.TT(tn.tensor(self.basis[2](x[2]).transpose()), [(x[2].shape[0],self.N[2])])
        dB3 = tntt.TT(tn.tensor(self.basis[2](x[2],derivative=True).transpose()), [(x[2].shape[0],self.N[2])])
       
        if interp:
            lst =  [tn.reshape(tn.eye(self.N[k], dtype = tn.float64), [1,-1,self.N[k],1]) for k in range(3,len(self.N))]
            if len(lst)&gt;0:
                Bp = tntt.TT(lst)       
            else:
                Bp = None 
        else:
            lst =  [tn.tensor(self.basis[k](x[k]).transpose().reshape([1,-1,self.basis[k].N,1])) for k in range(3,len(self.N))]
            if len(lst)&gt;0:
                Bp = tntt.TT(lst)       
            else:
                Bp = None
            
        Btt = dB1 ** B2 ** B3
        det1 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** dB2 ** B3
        det1 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** B2 ** dB3
        det1 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** dB2 ** B3
        det2 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** B2 ** dB3
        det2 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = dB1 ** B2 ** B3
        det2 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** B2 ** dB3
        det3 = (Btt ** Bp) @ self.Xs[0] 
        Btt = dB1 ** B2 ** B3
        det3 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** dB2 ** B3
        det3 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** B2 ** dB3
        det4 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** dB2 ** B3
        det4 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = dB1 ** B2 ** B3
        det4 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = dB1 ** B2 ** B3
        det5 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** B2 ** dB3
        det5 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** dB2 ** B3
        det5 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** dB2 ** B3
        det6 = (Btt ** Bp) @ self.Xs[0] 
        Btt = dB1 ** B2 ** B3
        det6 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** B2 ** dB3
        det6 *= (Btt ** Bp)@ self.Xs[2] 
       
        res = (det1 + det2 + det3 - det4 - det5 - det6).round(eps)
        return res 
    
    def integral_tensor(self,eps = 1e-12):
        &#34;&#34;&#34;
        
        
        &#34;&#34;&#34; 
        p1, w1 = points_basis(self.basis[0])
        p2, w2 = points_basis(self.basis[1])
        p3, w3 = points_basis(self.basis[2])
    
        cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
        
        cores[0] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)))
        cores[1] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)))
        cores[2] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)))
        
        return tntt.TT(cores)
        
    def mass_interp(self, eps = 1e-12):
        &#34;&#34;&#34;
        

        Args:
            eps ([type], optional): [description]. Defaults to 1e-12.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        p1, w1 = points_basis(self.basis[0])
        p2, w2 = points_basis(self.basis[1])
        p3, w3 = points_basis(self.basis[2])
    
        
        cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
                
        
        cores[0] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)),tn.tensor(self.basis[0](p1)))
        cores[1] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)),tn.tensor(self.basis[1](p2)))
        cores[2] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)),tn.tensor(self.basis[2](p3)))

        for i in range(3,len(cores)):
            cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype = tn.float64),tn.eye(cores[i].shape[1], dtype = tn.float64))
            
        return tntt.TT(cores)

    def stiffness_interp(self, eps = 1e-10, func = None, func_reference = None, rankinv = 1024, device = None, verb = False, qtt = False):
        &#34;&#34;&#34;
        

        Args:
            eps ([type], optional): [description]. Defaults to 1e-10.
            func ([type], optional): [description]. Defaults to None.
            func_reference ([type], optional): [description]. Defaults to None.
            rankinv (int, optional): [description]. Defaults to 1024.
            device ([type], optional): [description]. Defaults to None.
            verb (bool, optional): [description]. Defaults to False.
            qtt (bool, optional): [description]. Defaults to False.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        
        p1, w1 = points_basis(self.basis[0],mult=2)
        p2, w2 = points_basis(self.basis[1],mult=2)
        p3, w3 = points_basis(self.basis[2],mult=2)
        ps = [tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)]
        ws = [tn.tensor(w1), tn.tensor(w2), tn.tensor(w3)]
        
        params = [tn.tensor(b.interpolating_points()[0]) for b in self.basis[3:]]
        
        tme = datetime.datetime.now()
        Og_tt = self.eval_omega([p1,p2,p3], eps)
        tme = datetime.datetime.now() - tme
        if verb: print(&#39;time omega&#39; , tme,flush=True)

        if qtt: 
            Nqtt = qtt_shape(Og_tt, list(range(len(Og_tt.N))))
            if verb:
                print(&#39;QTT enabled:&#39;)
                print(list(Og_tt.N))
                print(&#39;  || &#39;)
                print(&#39;  \/  &#39;)
                print(Nqtt)
            No =list(Og_tt.N)
            Og_tt = tntt.reshape(Og_tt,Nqtt)     


        if not qtt:
            tme = datetime.datetime.now()
            # Ogi_tt = 1/Og_tt
            Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8,  verbose = False, preconditioner = &#39;c&#39;)
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;time omega inv&#39; , tme,&#39; rank &#39;,Ogi_tt.R,flush=True)
            #if verb: print(&#39;invert error &#39;,(Ogi_tt*Og_tt-tt.ones(Og_tt.n)).norm()/tt.ones(Og_tt.n).norm())
            Ogi_tt = Ogi_tt.round(eps)
        else:
            pass
            # Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8)
        

        if func != None or func_reference != None:
            tmp = tntt.meshgrid(params)
            if func_reference == None:
                X, Y, Z = self(ps, (False,False,False))
                F_tt = tntt.interpolate.function_interpolate(func, [X, Y, Z]+[tntt.ones(X.N[:3]) ** t for t in tmp], eps = eps , verbose=False).round(eps)
                
                if verb: print(&#39;rank of Frtt is &#39;,F_tt.r)
            else:
                F_tt = tntt.interpolate.function_interpolate(func_reference,tntt.meshgrid(ps+params),eps = eps,verbose = False).round(eps)
                if verb: print(&#39;rank of Ftt is &#39;,F_tt.R)
        else:
            F_tt = tntt.ones(Og_tt.N)

        if qtt:
            F_tt = tntt.reshape(F_tt,Nqtt) 
        else: 
            Ogi_tt = (Ogi_tt * F_tt).round(eps)
        
        tme = datetime.datetime.now()
        g11, g21, g31 = GTT(ps, self.basis, self.Xs, (True,False,False))
        g12, g22, g32 = GTT(ps, self.basis, self.Xs, (False,True,False))
        g13, g23, g33 = GTT(ps, self.basis, self.Xs, (False,False,True))
        if device!=None:
            g11 = g11.to(device)
            g12 = g12.to(device)
            g13 = g13.to(device)
            g21 = g21.to(device)
            g22 = g22.to(device)
            g23 = g23.to(device)
            g31 = g31.to(device)
            g32 = g32.to(device)
            g33 = g33.to(device)

        if verb:
            print(g11.R) 
            print(g12.R) 
            print(g13.R) 
            print(g21.R) 
            print(g22.R) 
            print(g23.R) 
            print(g31.R) 
            print(g32.R) 
            print(g33.R) 
        tme = datetime.datetime.now() -tme
        if verb:  print(&#39;G computed in &#39; , tme)
        
        # adjugate
        tme = datetime.datetime.now()
        h11,h12,h13 = (g22*g33-g23*g32, g13*g32-g12*g33, g12*g23-g13*g22)
        h21,h22,h23 = (g23*g31-g21*g33, g11*g33-g13*g31, g13*g21-g11*g23)
        h31,h32,h33 = (g21*g32-g22*g31, g12*g31-g11*g32, g11*g22-g12*g21)
        
        # tme = datetime.datetime.now()
        H = [[h11.round(eps),h12.round(eps),h13.round(eps)],[h21.round(eps),h22.round(eps),h23.round(eps)],[h31.round(eps),h32.round(eps),h33.round(eps)]]

        tme = datetime.datetime.now() -tme
        if verb: print(&#39;H computed in&#39; , tme)
        
        Bs = [tn.tensor(self.basis[i](ps[i]).transpose()).to(device) for i in range(3)]
        dBs = [tn.tensor(self.basis[i](ps[i],derivative = True).transpose()).to(device) for i in range(3)]
                
        N = self.Xs[0].N
        S = None
        SS = None
        Hs = dict()
        
        # the size of the bands
        band_size = [b.deg for b in self.basis[:3]]+[1]*len(N[3:])

        if qtt: 
            for i in range(3):
                for j in range(3):
                    H[i][j] = tntt.reshape(H[i][j], Nqtt, eps)
                    # print(H[i][j].r)

        for alpha in range(3):
            for beta in range(3):
                if verb: print(&#39;alpha, beta = &#39;,alpha,beta)
                tme = datetime.datetime.now()

                tmp = H[alpha][0]*H[beta][0]+H[alpha][1]*H[beta][1]+H[alpha][2]*H[beta][2]
                tmp = tmp.round(eps,rankinv)
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 1 &#39; , tme)


                tme = datetime.datetime.now()
                if not qtt:
                    tmp = tmp*Ogi_tt
                    tmp = tmp.round(eps,rankinv)
                else:
                    tmp = tntt.elementwise_divide(tmp,Og_tt, starting_tensor = tmp, eps=eps,kick=8, nswp = 50, local_iterations = 20, resets = 4, preconditioner = &#39;c&#39;)*F_tt 
                    # tmp = tmp*Ogi_tt*F_tt

            #  print(&#39;Rank of product&#39;,tmp.r)
                
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 2 &#39; , tme,&#39; rank &#39;,tmp.R)
                
                # print(&#39;ERR &#39;,(tmp-tmp2).norm()/tmp.norm())

                if qtt: tmp = tntt.reshape(tmp,No)
                
                # tmp = H[alpha][0]*Hi[beta][0]+H[alpha][1]*Hi[beta][1]+H[alpha][2]*Hi[beta][2]
                # tmp = tmp.round(eps,rankinv)
                
                tme = datetime.datetime.now()
                cores = tmp.cores
                
                tme = datetime.datetime.now()
                # cores[0] = np.einsum(&#39;rjs,j,jm,jn-&gt;rmns&#39;,cores[0],w1,dB1 if alpha==0 else B1,dB1 if beta==0 else B1)
                # print(cores[0].shape,w1.shape)
                for i in range(3):
                    cores[i] = tn.einsum(&#39;rjs,j-&gt;rjs&#39;,cores[i],ws[i])
                    tmp = tn.einsum(&#39;jm,jn-&gt;jmn&#39;,dBs[i] if alpha==i else Bs[i], dBs[i] if beta==i else Bs[i])
                    cores[i] = tn.einsum(&#39;rjs,jmn-&gt;rmns&#39;,cores[i],tmp)
                    
                for i in range(3,len(cores)):
                    cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype=tn.float64),tn.eye(cores[i].shape[1],dtype=tn.float64))
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\t\ttime &#39; , tme)
                
                
                tme = datetime.datetime.now()
                ss = tntt.TT([tn.tensor(bandcore2ttcore(cores[i].cpu().numpy(),band_size[i])) for i in range(len(cores))]).to(device)

                
                SS = ss if SS==None else SS+ss 
                
                
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 4 &#39; , tme)
            tme = datetime.datetime.now()

            SS = SS.round(eps)
            
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\ttime ROUND &#39; , tme)
        
        cores = SS.cores
        SS = tntt.TT([tn.tensor(ttcore2bandcore(cores[i].cpu().numpy(),N[i],band_size[i])) for i in range(len(N))])

        return SS

    
    def plot_domain(self, params = None, bounds = None, fig = None, wireframe = True, frame_color = &#39;r&#39;, n = 12, surface_color = &#39;blue&#39;,alpha = 0.4):
        &#34;&#34;&#34;
        Plot the domain for a given parameter (if any parameter dependence exists).

        Args:
            params ([type], optional): [description]. Defaults to None.
            bounds ([type], optional): [description]. Defaults to None.
            fig ([type], optional): [description]. Defaults to None.
            wireframe (bool, optional): [description]. Defaults to True.
            frame_color (str, optional): [description]. Defaults to &#39;r&#39;.
            n (int, optional): [description]. Defaults to 12.
            surface_color (str, optional): [description]. Defaults to &#39;blue&#39;.
            alpha (float, optional): [description]. Defaults to 0.4.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if fig == None:
            fig = plt.figure()
            ax = plt.axes(projection=&#39;3d&#39;)
        else:
            ax = fig.gca()
            
        if wireframe:
            plot_func = ax.plot_wireframe
        else:
            plot_func = ax.plot_surface
        
        if bounds == None:
            bounds = [b.interval for b in self.basis[:3]]
            
        if surface_color != None:
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        if frame_color != None:
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        return fig

    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tt_iga.tt_iga.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>basis)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function():
      
    def __init__(self, basis):
        &#34;&#34;&#34;
        

        Args:
            basis ([type]): [description]
        &#34;&#34;&#34;
        self.N = [b.N for b in basis]
        self.basis = basis
        
    def interpolate(self, function, geometry = None, eps = 1e-12):
        &#34;&#34;&#34;
        

        Args:
            function ([type]): [description]
            geometry ([type], optional): [description]. Defaults to None.
            eps ([type], optional): [description]. Defaults to 1e-12.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
        Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
        
        corz = [tn.reshape(Mg[i].t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
        Gm = tntt.TT(corz)
        
        if geometry == None:
            X = tntt.TT(Xg[0])**tntt.ones(self.N[1:])   
            Y = tntt.ones(self.N[:1]) ** tntt.TT(Xg[1]) ** tntt.ones(self.N[2:]) 
            Z = tntt.ones(self.N[:2]) ** tntt.TT(Xg[2]) ** tntt.ones(self.N[3:])  
        else:
            X,Y,Z = geometry(Xg)

        if len(self.basis)==3:
            evals = tntt.interpolate.function_interpolate(function, [X, Y, Z], eps)
        else:
            Np = len(self.basis[3:])
            meshgrid = tntt.meshgrid([x for x in Xg[3:]])
            meshgrid = [X,Y,Z] + [tntt.ones([n for n in self.N[:3]])**m for m in meshgrid]
            evals = tntt.interpolate.function_interpolate(function, meshgrid, eps, verbose = False)
            

        dofs = tntt.solvers.amen_solve(Gm,evals,x0 = evals,eps = eps,verbose = False)
        self.dofs = dofs
        
        return dofs
    
    def __call__(self, x, deriv = None):
        &#34;&#34;&#34;
        

        Args:
            x ([type]): [description]
            deriv ([type], optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if deriv == None:
            deriv = [False]*len(self.N)
        
        Bs = [tn.tensor(self.basis[i](x[i].numpy(),derivative=deriv[i]), dtype = tn.float64).t() for i in range(len(self.N))]
        B_tt = tntt.TT([tn.reshape(m,[1,m.shape[0],-1,1]) for m in Bs])
        
        val = B_tt @ self.dofs
        
        return val 
    
    def L2error(self, function, geometry_map = None, level = 32):
        &#34;&#34;&#34;
        

        Args:
            function ([type]): [description]
            geometry_map ([type], optional): [description]. Defaults to None.
            level (int, optional): [description]. Defaults to 32.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        pts, ws = np.polynomial.legendre.leggauss(level)
        pts = (pts+1)*0.5
        ws = ws/2
        
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
         
        if geometry_map != None:
            X,Y,Z = geometry_map([tn.tensor(pts)]*len(self.N))
            Og_tt = geometry_map.eval_omega([tn.tensor(pts)]*3, interp=True)
        else:
            X,Y,Z = geometry_map(Xg)
        
        B_tt = tntt.TT(self.basis[0](pts),shape = [(self.basis[0].N,pts.size)]) ** tntt.TT(self.basis[1](pts),shape = [(self.basis[1].N,pts.size)]) ** tntt.TT(self.basis[2](pts),shape = [(self.basis[2].N,pts.size)]) 
        B_tt = B_tt.t()
        C_tt = tntt.eye(B_tt.M)
        
        for i in range(3,len(self.basis)):
            B_tt = B_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
            C_tt = C_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
        # X = C_tt @ X
        # Y = C_tt @ Y
        # Z = C_tt @ Z
        Og_tt = C_tt @ Og_tt
        d_eval = B_tt @ self.dofs
        
        if len(self.basis)==3:
            f_eval = tntt.interpolate.function_interpolate(function, [X, Y, Z], 1e-13)
        else:
            Np = len(self.N[3:])
            meshgrid = tntt.meshgrid([tn.tensor(pts)]*Np)
            meshgrid = [X,Y,Z] + [tntt.ones([pts.size]*3)**m for m in meshgrid]
            f_eval = tntt.interpolate.function_interpolate(function, meshgrid, 1e-13)
        
        diff = f_eval-d_eval
        Ws = tntt.rank1TT(len(self.basis)*[tn.tensor(ws)])
        
        integral = np.abs(tntt.dot(Ws*diff,diff*Og_tt).numpy())
        # print(integral)
        return np.sqrt(integral)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tt_iga.tt_iga.Function.L2error"><code class="name flex">
<span>def <span class="ident">L2error</span></span>(<span>self, function, geometry_map=None, level=32)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>geometry_map</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 32.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def L2error(self, function, geometry_map = None, level = 32):
    &#34;&#34;&#34;
    

    Args:
        function ([type]): [description]
        geometry_map ([type], optional): [description]. Defaults to None.
        level (int, optional): [description]. Defaults to 32.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    pts, ws = np.polynomial.legendre.leggauss(level)
    pts = (pts+1)*0.5
    ws = ws/2
    
    Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
     
    if geometry_map != None:
        X,Y,Z = geometry_map([tn.tensor(pts)]*len(self.N))
        Og_tt = geometry_map.eval_omega([tn.tensor(pts)]*3, interp=True)
    else:
        X,Y,Z = geometry_map(Xg)
    
    B_tt = tntt.TT(self.basis[0](pts),shape = [(self.basis[0].N,pts.size)]) ** tntt.TT(self.basis[1](pts),shape = [(self.basis[1].N,pts.size)]) ** tntt.TT(self.basis[2](pts),shape = [(self.basis[2].N,pts.size)]) 
    B_tt = B_tt.t()
    C_tt = tntt.eye(B_tt.M)
    
    for i in range(3,len(self.basis)):
        B_tt = B_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
        C_tt = C_tt ** tntt.TT(self.basis[i](pts).transpose(), shape = [(pts.size, self.basis[i].N)])
    # X = C_tt @ X
    # Y = C_tt @ Y
    # Z = C_tt @ Z
    Og_tt = C_tt @ Og_tt
    d_eval = B_tt @ self.dofs
    
    if len(self.basis)==3:
        f_eval = tntt.interpolate.function_interpolate(function, [X, Y, Z], 1e-13)
    else:
        Np = len(self.N[3:])
        meshgrid = tntt.meshgrid([tn.tensor(pts)]*Np)
        meshgrid = [X,Y,Z] + [tntt.ones([pts.size]*3)**m for m in meshgrid]
        f_eval = tntt.interpolate.function_interpolate(function, meshgrid, 1e-13)
    
    diff = f_eval-d_eval
    Ws = tntt.rank1TT(len(self.basis)*[tn.tensor(ws)])
    
    integral = np.abs(tntt.dot(Ws*diff,diff*Og_tt).numpy())
    # print(integral)
    return np.sqrt(integral)</code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Function.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, function, geometry=None, eps=1e-12)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>geometry</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to 1e-12.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, function, geometry = None, eps = 1e-12):
    &#34;&#34;&#34;
    

    Args:
        function ([type]): [description]
        geometry ([type], optional): [description]. Defaults to None.
        eps ([type], optional): [description]. Defaults to 1e-12.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
    Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
    
    corz = [tn.reshape(Mg[i].t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
    Gm = tntt.TT(corz)
    
    if geometry == None:
        X = tntt.TT(Xg[0])**tntt.ones(self.N[1:])   
        Y = tntt.ones(self.N[:1]) ** tntt.TT(Xg[1]) ** tntt.ones(self.N[2:]) 
        Z = tntt.ones(self.N[:2]) ** tntt.TT(Xg[2]) ** tntt.ones(self.N[3:])  
    else:
        X,Y,Z = geometry(Xg)

    if len(self.basis)==3:
        evals = tntt.interpolate.function_interpolate(function, [X, Y, Z], eps)
    else:
        Np = len(self.basis[3:])
        meshgrid = tntt.meshgrid([x for x in Xg[3:]])
        meshgrid = [X,Y,Z] + [tntt.ones([n for n in self.N[:3]])**m for m in meshgrid]
        evals = tntt.interpolate.function_interpolate(function, meshgrid, eps, verbose = False)
        

    dofs = tntt.solvers.amen_solve(Gm,evals,x0 = evals,eps = eps,verbose = False)
    self.dofs = dofs
    
    return dofs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tt_iga.tt_iga.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
<span>(</span><span>basis, Xs=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>Xs</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry():
    
    def __init__(self, basis, Xs = None):
        &#34;&#34;&#34;
        

        Args:
            basis ([type]): [description]
            Xs ([type], optional): [description]. Defaults to None.
        &#34;&#34;&#34;
        self.N = [b.N for b in basis]
        self.basis = basis
        self.Xs = Xs
        
    def interpolate(self, geometry_map, eps = 1e-13):
        &#34;&#34;&#34;
        Interpolates the given geometry map.

        Args:
            geometry_map (list[function]): [description]
            eps ([type], optional): [description]. Defaults to 1e-13.
        &#34;&#34;&#34;
        Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
        Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
        
        corz = [tn.reshape(tn.linalg.inv(Mg[i]).t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
        Gmi = tntt.TT(corz)
        
        Xs = []
        
        for i in range(3):
            evals = tntt.interpolate.function_interpolate(geometry_map[i], tntt.meshgrid(Xg), eps = eps).round(eps)
            dofs = (Gmi @ evals).round(eps)
            Xs.append(dofs)
            
        self.Xs = Xs
        
    def __call__(self, x, deriv = None):
        
        if deriv == None:
            deriv = [False] * len(self.N)
            
        Bs = [tn.tensor(self.basis[i](x[i].numpy(),derivative=deriv[i]), dtype = tn.float64).t() for i in range(len(self.N))]

        B_tt = tntt.TT([tn.reshape(m,[1,m.shape[0],-1,1]) for m in Bs])
        
        ret = []
        
        for X in self.Xs:
            ret.append(B_tt @ X)
        
        return ret

    def eval_omega(self, x, eps = 1e-12, interp = True):
        
        #evgaluate univariate bsplines and their derivative 
        B1 = tntt.TT(tn.tensor(self.basis[0](x[0]).transpose()), [(x[0].shape[0],self.N[0])])
        dB1 = tntt.TT(tn.tensor(self.basis[0](x[0],derivative=True).transpose()), [(x[0].shape[0],self.N[0])])
        B2 = tntt.TT(tn.tensor(self.basis[1](x[1]).transpose()), [(x[1].shape[0],self.N[1])])
        dB2 = tntt.TT(tn.tensor(self.basis[1](x[1],derivative=True).transpose()), [(x[1].shape[0],self.N[1])])
        B3 = tntt.TT(tn.tensor(self.basis[2](x[2]).transpose()), [(x[2].shape[0],self.N[2])])
        dB3 = tntt.TT(tn.tensor(self.basis[2](x[2],derivative=True).transpose()), [(x[2].shape[0],self.N[2])])
       
        if interp:
            lst =  [tn.reshape(tn.eye(self.N[k], dtype = tn.float64), [1,-1,self.N[k],1]) for k in range(3,len(self.N))]
            if len(lst)&gt;0:
                Bp = tntt.TT(lst)       
            else:
                Bp = None 
        else:
            lst =  [tn.tensor(self.basis[k](x[k]).transpose().reshape([1,-1,self.basis[k].N,1])) for k in range(3,len(self.N))]
            if len(lst)&gt;0:
                Bp = tntt.TT(lst)       
            else:
                Bp = None
            
        Btt = dB1 ** B2 ** B3
        det1 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** dB2 ** B3
        det1 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** B2 ** dB3
        det1 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** dB2 ** B3
        det2 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** B2 ** dB3
        det2 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = dB1 ** B2 ** B3
        det2 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** B2 ** dB3
        det3 = (Btt ** Bp) @ self.Xs[0] 
        Btt = dB1 ** B2 ** B3
        det3 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** dB2 ** B3
        det3 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** B2 ** dB3
        det4 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** dB2 ** B3
        det4 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = dB1 ** B2 ** B3
        det4 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = dB1 ** B2 ** B3
        det5 = (Btt ** Bp) @ self.Xs[0] 
        Btt = B1 ** B2 ** dB3
        det5 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** dB2 ** B3
        det5 *= (Btt ** Bp)@ self.Xs[2] 
        
        Btt = B1 ** dB2 ** B3
        det6 = (Btt ** Bp) @ self.Xs[0] 
        Btt = dB1 ** B2 ** B3
        det6 *= (Btt ** Bp) @ self.Xs[1] 
        Btt = B1 ** B2 ** dB3
        det6 *= (Btt ** Bp)@ self.Xs[2] 
       
        res = (det1 + det2 + det3 - det4 - det5 - det6).round(eps)
        return res 
    
    def integral_tensor(self,eps = 1e-12):
        &#34;&#34;&#34;
        
        
        &#34;&#34;&#34; 
        p1, w1 = points_basis(self.basis[0])
        p2, w2 = points_basis(self.basis[1])
        p3, w3 = points_basis(self.basis[2])
    
        cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
        
        cores[0] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)))
        cores[1] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)))
        cores[2] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)))
        
        return tntt.TT(cores)
        
    def mass_interp(self, eps = 1e-12):
        &#34;&#34;&#34;
        

        Args:
            eps ([type], optional): [description]. Defaults to 1e-12.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        p1, w1 = points_basis(self.basis[0])
        p2, w2 = points_basis(self.basis[1])
        p3, w3 = points_basis(self.basis[2])
    
        
        cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
                
        
        cores[0] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)),tn.tensor(self.basis[0](p1)))
        cores[1] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)),tn.tensor(self.basis[1](p2)))
        cores[2] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)),tn.tensor(self.basis[2](p3)))

        for i in range(3,len(cores)):
            cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype = tn.float64),tn.eye(cores[i].shape[1], dtype = tn.float64))
            
        return tntt.TT(cores)

    def stiffness_interp(self, eps = 1e-10, func = None, func_reference = None, rankinv = 1024, device = None, verb = False, qtt = False):
        &#34;&#34;&#34;
        

        Args:
            eps ([type], optional): [description]. Defaults to 1e-10.
            func ([type], optional): [description]. Defaults to None.
            func_reference ([type], optional): [description]. Defaults to None.
            rankinv (int, optional): [description]. Defaults to 1024.
            device ([type], optional): [description]. Defaults to None.
            verb (bool, optional): [description]. Defaults to False.
            qtt (bool, optional): [description]. Defaults to False.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        
        p1, w1 = points_basis(self.basis[0],mult=2)
        p2, w2 = points_basis(self.basis[1],mult=2)
        p3, w3 = points_basis(self.basis[2],mult=2)
        ps = [tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)]
        ws = [tn.tensor(w1), tn.tensor(w2), tn.tensor(w3)]
        
        params = [tn.tensor(b.interpolating_points()[0]) for b in self.basis[3:]]
        
        tme = datetime.datetime.now()
        Og_tt = self.eval_omega([p1,p2,p3], eps)
        tme = datetime.datetime.now() - tme
        if verb: print(&#39;time omega&#39; , tme,flush=True)

        if qtt: 
            Nqtt = qtt_shape(Og_tt, list(range(len(Og_tt.N))))
            if verb:
                print(&#39;QTT enabled:&#39;)
                print(list(Og_tt.N))
                print(&#39;  || &#39;)
                print(&#39;  \/  &#39;)
                print(Nqtt)
            No =list(Og_tt.N)
            Og_tt = tntt.reshape(Og_tt,Nqtt)     


        if not qtt:
            tme = datetime.datetime.now()
            # Ogi_tt = 1/Og_tt
            Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8,  verbose = False, preconditioner = &#39;c&#39;)
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;time omega inv&#39; , tme,&#39; rank &#39;,Ogi_tt.R,flush=True)
            #if verb: print(&#39;invert error &#39;,(Ogi_tt*Og_tt-tt.ones(Og_tt.n)).norm()/tt.ones(Og_tt.n).norm())
            Ogi_tt = Ogi_tt.round(eps)
        else:
            pass
            # Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8)
        

        if func != None or func_reference != None:
            tmp = tntt.meshgrid(params)
            if func_reference == None:
                X, Y, Z = self(ps, (False,False,False))
                F_tt = tntt.interpolate.function_interpolate(func, [X, Y, Z]+[tntt.ones(X.N[:3]) ** t for t in tmp], eps = eps , verbose=False).round(eps)
                
                if verb: print(&#39;rank of Frtt is &#39;,F_tt.r)
            else:
                F_tt = tntt.interpolate.function_interpolate(func_reference,tntt.meshgrid(ps+params),eps = eps,verbose = False).round(eps)
                if verb: print(&#39;rank of Ftt is &#39;,F_tt.R)
        else:
            F_tt = tntt.ones(Og_tt.N)

        if qtt:
            F_tt = tntt.reshape(F_tt,Nqtt) 
        else: 
            Ogi_tt = (Ogi_tt * F_tt).round(eps)
        
        tme = datetime.datetime.now()
        g11, g21, g31 = GTT(ps, self.basis, self.Xs, (True,False,False))
        g12, g22, g32 = GTT(ps, self.basis, self.Xs, (False,True,False))
        g13, g23, g33 = GTT(ps, self.basis, self.Xs, (False,False,True))
        if device!=None:
            g11 = g11.to(device)
            g12 = g12.to(device)
            g13 = g13.to(device)
            g21 = g21.to(device)
            g22 = g22.to(device)
            g23 = g23.to(device)
            g31 = g31.to(device)
            g32 = g32.to(device)
            g33 = g33.to(device)

        if verb:
            print(g11.R) 
            print(g12.R) 
            print(g13.R) 
            print(g21.R) 
            print(g22.R) 
            print(g23.R) 
            print(g31.R) 
            print(g32.R) 
            print(g33.R) 
        tme = datetime.datetime.now() -tme
        if verb:  print(&#39;G computed in &#39; , tme)
        
        # adjugate
        tme = datetime.datetime.now()
        h11,h12,h13 = (g22*g33-g23*g32, g13*g32-g12*g33, g12*g23-g13*g22)
        h21,h22,h23 = (g23*g31-g21*g33, g11*g33-g13*g31, g13*g21-g11*g23)
        h31,h32,h33 = (g21*g32-g22*g31, g12*g31-g11*g32, g11*g22-g12*g21)
        
        # tme = datetime.datetime.now()
        H = [[h11.round(eps),h12.round(eps),h13.round(eps)],[h21.round(eps),h22.round(eps),h23.round(eps)],[h31.round(eps),h32.round(eps),h33.round(eps)]]

        tme = datetime.datetime.now() -tme
        if verb: print(&#39;H computed in&#39; , tme)
        
        Bs = [tn.tensor(self.basis[i](ps[i]).transpose()).to(device) for i in range(3)]
        dBs = [tn.tensor(self.basis[i](ps[i],derivative = True).transpose()).to(device) for i in range(3)]
                
        N = self.Xs[0].N
        S = None
        SS = None
        Hs = dict()
        
        # the size of the bands
        band_size = [b.deg for b in self.basis[:3]]+[1]*len(N[3:])

        if qtt: 
            for i in range(3):
                for j in range(3):
                    H[i][j] = tntt.reshape(H[i][j], Nqtt, eps)
                    # print(H[i][j].r)

        for alpha in range(3):
            for beta in range(3):
                if verb: print(&#39;alpha, beta = &#39;,alpha,beta)
                tme = datetime.datetime.now()

                tmp = H[alpha][0]*H[beta][0]+H[alpha][1]*H[beta][1]+H[alpha][2]*H[beta][2]
                tmp = tmp.round(eps,rankinv)
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 1 &#39; , tme)


                tme = datetime.datetime.now()
                if not qtt:
                    tmp = tmp*Ogi_tt
                    tmp = tmp.round(eps,rankinv)
                else:
                    tmp = tntt.elementwise_divide(tmp,Og_tt, starting_tensor = tmp, eps=eps,kick=8, nswp = 50, local_iterations = 20, resets = 4, preconditioner = &#39;c&#39;)*F_tt 
                    # tmp = tmp*Ogi_tt*F_tt

            #  print(&#39;Rank of product&#39;,tmp.r)
                
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 2 &#39; , tme,&#39; rank &#39;,tmp.R)
                
                # print(&#39;ERR &#39;,(tmp-tmp2).norm()/tmp.norm())

                if qtt: tmp = tntt.reshape(tmp,No)
                
                # tmp = H[alpha][0]*Hi[beta][0]+H[alpha][1]*Hi[beta][1]+H[alpha][2]*Hi[beta][2]
                # tmp = tmp.round(eps,rankinv)
                
                tme = datetime.datetime.now()
                cores = tmp.cores
                
                tme = datetime.datetime.now()
                # cores[0] = np.einsum(&#39;rjs,j,jm,jn-&gt;rmns&#39;,cores[0],w1,dB1 if alpha==0 else B1,dB1 if beta==0 else B1)
                # print(cores[0].shape,w1.shape)
                for i in range(3):
                    cores[i] = tn.einsum(&#39;rjs,j-&gt;rjs&#39;,cores[i],ws[i])
                    tmp = tn.einsum(&#39;jm,jn-&gt;jmn&#39;,dBs[i] if alpha==i else Bs[i], dBs[i] if beta==i else Bs[i])
                    cores[i] = tn.einsum(&#39;rjs,jmn-&gt;rmns&#39;,cores[i],tmp)
                    
                for i in range(3,len(cores)):
                    cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype=tn.float64),tn.eye(cores[i].shape[1],dtype=tn.float64))
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\t\ttime &#39; , tme)
                
                
                tme = datetime.datetime.now()
                ss = tntt.TT([tn.tensor(bandcore2ttcore(cores[i].cpu().numpy(),band_size[i])) for i in range(len(cores))]).to(device)

                
                SS = ss if SS==None else SS+ss 
                
                
                tme = datetime.datetime.now() -tme
                if verb: print(&#39;\ttime 4 &#39; , tme)
            tme = datetime.datetime.now()

            SS = SS.round(eps)
            
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\ttime ROUND &#39; , tme)
        
        cores = SS.cores
        SS = tntt.TT([tn.tensor(ttcore2bandcore(cores[i].cpu().numpy(),N[i],band_size[i])) for i in range(len(N))])

        return SS

    
    def plot_domain(self, params = None, bounds = None, fig = None, wireframe = True, frame_color = &#39;r&#39;, n = 12, surface_color = &#39;blue&#39;,alpha = 0.4):
        &#34;&#34;&#34;
        Plot the domain for a given parameter (if any parameter dependence exists).

        Args:
            params ([type], optional): [description]. Defaults to None.
            bounds ([type], optional): [description]. Defaults to None.
            fig ([type], optional): [description]. Defaults to None.
            wireframe (bool, optional): [description]. Defaults to True.
            frame_color (str, optional): [description]. Defaults to &#39;r&#39;.
            n (int, optional): [description]. Defaults to 12.
            surface_color (str, optional): [description]. Defaults to &#39;blue&#39;.
            alpha (float, optional): [description]. Defaults to 0.4.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if fig == None:
            fig = plt.figure()
            ax = plt.axes(projection=&#39;3d&#39;)
        else:
            ax = fig.gca()
            
        if wireframe:
            plot_func = ax.plot_wireframe
        else:
            plot_func = ax.plot_surface
        
        if bounds == None:
            bounds = [b.interval for b in self.basis[:3]]
            
        if surface_color != None:
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        if frame_color != None:
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
            
            x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
            ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        return fig</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tt_iga.tt_iga.Geometry.eval_omega"><code class="name flex">
<span>def <span class="ident">eval_omega</span></span>(<span>self, x, eps=1e-12, interp=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_omega(self, x, eps = 1e-12, interp = True):
    
    #evgaluate univariate bsplines and their derivative 
    B1 = tntt.TT(tn.tensor(self.basis[0](x[0]).transpose()), [(x[0].shape[0],self.N[0])])
    dB1 = tntt.TT(tn.tensor(self.basis[0](x[0],derivative=True).transpose()), [(x[0].shape[0],self.N[0])])
    B2 = tntt.TT(tn.tensor(self.basis[1](x[1]).transpose()), [(x[1].shape[0],self.N[1])])
    dB2 = tntt.TT(tn.tensor(self.basis[1](x[1],derivative=True).transpose()), [(x[1].shape[0],self.N[1])])
    B3 = tntt.TT(tn.tensor(self.basis[2](x[2]).transpose()), [(x[2].shape[0],self.N[2])])
    dB3 = tntt.TT(tn.tensor(self.basis[2](x[2],derivative=True).transpose()), [(x[2].shape[0],self.N[2])])
   
    if interp:
        lst =  [tn.reshape(tn.eye(self.N[k], dtype = tn.float64), [1,-1,self.N[k],1]) for k in range(3,len(self.N))]
        if len(lst)&gt;0:
            Bp = tntt.TT(lst)       
        else:
            Bp = None 
    else:
        lst =  [tn.tensor(self.basis[k](x[k]).transpose().reshape([1,-1,self.basis[k].N,1])) for k in range(3,len(self.N))]
        if len(lst)&gt;0:
            Bp = tntt.TT(lst)       
        else:
            Bp = None
        
    Btt = dB1 ** B2 ** B3
    det1 = (Btt ** Bp) @ self.Xs[0] 
    Btt = B1 ** dB2 ** B3
    det1 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = B1 ** B2 ** dB3
    det1 *= (Btt ** Bp)@ self.Xs[2] 
    
    Btt = B1 ** dB2 ** B3
    det2 = (Btt ** Bp) @ self.Xs[0] 
    Btt = B1 ** B2 ** dB3
    det2 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = dB1 ** B2 ** B3
    det2 *= (Btt ** Bp)@ self.Xs[2] 
    
    Btt = B1 ** B2 ** dB3
    det3 = (Btt ** Bp) @ self.Xs[0] 
    Btt = dB1 ** B2 ** B3
    det3 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = B1 ** dB2 ** B3
    det3 *= (Btt ** Bp)@ self.Xs[2] 
    
    Btt = B1 ** B2 ** dB3
    det4 = (Btt ** Bp) @ self.Xs[0] 
    Btt = B1 ** dB2 ** B3
    det4 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = dB1 ** B2 ** B3
    det4 *= (Btt ** Bp)@ self.Xs[2] 
    
    Btt = dB1 ** B2 ** B3
    det5 = (Btt ** Bp) @ self.Xs[0] 
    Btt = B1 ** B2 ** dB3
    det5 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = B1 ** dB2 ** B3
    det5 *= (Btt ** Bp)@ self.Xs[2] 
    
    Btt = B1 ** dB2 ** B3
    det6 = (Btt ** Bp) @ self.Xs[0] 
    Btt = dB1 ** B2 ** B3
    det6 *= (Btt ** Bp) @ self.Xs[1] 
    Btt = B1 ** B2 ** dB3
    det6 *= (Btt ** Bp)@ self.Xs[2] 
   
    res = (det1 + det2 + det3 - det4 - det5 - det6).round(eps)
    return res </code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Geometry.integral_tensor"><code class="name flex">
<span>def <span class="ident">integral_tensor</span></span>(<span>self, eps=1e-12)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integral_tensor(self,eps = 1e-12):
    &#34;&#34;&#34;
    
    
    &#34;&#34;&#34; 
    p1, w1 = points_basis(self.basis[0])
    p2, w2 = points_basis(self.basis[1])
    p3, w3 = points_basis(self.basis[2])

    cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
    
    cores[0] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)))
    cores[1] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)))
    cores[2] = tn.einsum(&#39;ijk,j,lj-&gt;ilk&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)))
    
    return tntt.TT(cores)</code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Geometry.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, geometry_map, eps=1e-13)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates the given geometry map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry_map</code></strong> :&ensp;<code>list[function]</code></dt>
<dd>[description]</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to 1e-13.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, geometry_map, eps = 1e-13):
    &#34;&#34;&#34;
    Interpolates the given geometry map.

    Args:
        geometry_map (list[function]): [description]
        eps ([type], optional): [description]. Defaults to 1e-13.
    &#34;&#34;&#34;
    Xg = [tn.tensor(b.interpolating_points()[0], dtype = tn.float64) for b in self.basis]
    Mg = [tn.tensor(b.interpolating_points()[1], dtype = tn.float64) for b in self.basis]
    
    corz = [tn.reshape(tn.linalg.inv(Mg[i]).t(), [1,Mg[i].shape[0],-1,1]) for i in range(len(Mg))]
    Gmi = tntt.TT(corz)
    
    Xs = []
    
    for i in range(3):
        evals = tntt.interpolate.function_interpolate(geometry_map[i], tntt.meshgrid(Xg), eps = eps).round(eps)
        dofs = (Gmi @ evals).round(eps)
        Xs.append(dofs)
        
    self.Xs = Xs</code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Geometry.mass_interp"><code class="name flex">
<span>def <span class="ident">mass_interp</span></span>(<span>self, eps=1e-12)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to 1e-12.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass_interp(self, eps = 1e-12):
    &#34;&#34;&#34;
    

    Args:
        eps ([type], optional): [description]. Defaults to 1e-12.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    p1, w1 = points_basis(self.basis[0])
    p2, w2 = points_basis(self.basis[1])
    p3, w3 = points_basis(self.basis[2])

    
    cores = self.eval_omega([tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)], eps).cores
            
    
    cores[0] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[0],tn.tensor(w1),tn.tensor(self.basis[0](p1)),tn.tensor(self.basis[0](p1)))
    cores[1] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[1],tn.tensor(w2),tn.tensor(self.basis[1](p2)),tn.tensor(self.basis[1](p2)))
    cores[2] = tn.einsum(&#39;rjs,j,mj,nj-&gt;rmns&#39;,cores[2],tn.tensor(w3),tn.tensor(self.basis[2](p3)),tn.tensor(self.basis[2](p3)))

    for i in range(3,len(cores)):
        cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype = tn.float64),tn.eye(cores[i].shape[1], dtype = tn.float64))
        
    return tntt.TT(cores)</code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Geometry.plot_domain"><code class="name flex">
<span>def <span class="ident">plot_domain</span></span>(<span>self, params=None, bounds=None, fig=None, wireframe=True, frame_color='r', n=12, surface_color='blue', alpha=0.4)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the domain for a given parameter (if any parameter dependence exists).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>wireframe</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>frame_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to 'r'.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 12.</dd>
<dt><strong><code>surface_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to 'blue'.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>[description]. Defaults to 0.4.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_domain(self, params = None, bounds = None, fig = None, wireframe = True, frame_color = &#39;r&#39;, n = 12, surface_color = &#39;blue&#39;,alpha = 0.4):
    &#34;&#34;&#34;
    Plot the domain for a given parameter (if any parameter dependence exists).

    Args:
        params ([type], optional): [description]. Defaults to None.
        bounds ([type], optional): [description]. Defaults to None.
        fig ([type], optional): [description]. Defaults to None.
        wireframe (bool, optional): [description]. Defaults to True.
        frame_color (str, optional): [description]. Defaults to &#39;r&#39;.
        n (int, optional): [description]. Defaults to 12.
        surface_color (str, optional): [description]. Defaults to &#39;blue&#39;.
        alpha (float, optional): [description]. Defaults to 0.4.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if fig == None:
        fig = plt.figure()
        ax = plt.axes(projection=&#39;3d&#39;)
    else:
        ax = fig.gca()
        
    if wireframe:
        plot_func = ax.plot_wireframe
    else:
        plot_func = ax.plot_surface
    
    if bounds == None:
        bounds = [b.interval for b in self.basis[:3]]
        
    if surface_color != None:
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[:,:,0].numpy().squeeze(), y.full()[:,:,0].numpy().squeeze(), z.full()[:,:,0].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[:,0,:].numpy().squeeze(), y.full()[:,0,:].numpy().squeeze(), z.full()[:,0,:].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
        
        x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        plot_func(x.full()[0,:,:].numpy().squeeze(), y.full()[0,:,:].numpy().squeeze(), z.full()[0,:,:].numpy().squeeze(), color = surface_color,alpha = alpha)
    
    if frame_color != None:
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][1],n, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][0],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][1],n, dtype = tn.float64),tn.linspace(bounds[2][1],bounds[2][1],1, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][0],bounds[0][0],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][0],bounds[1][0],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
        
        x,y,z = self([tn.linspace(bounds[0][1],bounds[0][1],1, dtype = tn.float64),tn.linspace(bounds[1][1],bounds[1][1],1, dtype = tn.float64),tn.linspace(bounds[2][0],bounds[2][1],n, dtype = tn.float64)]+([] if params ==None else params))
        ax.plot(x.full().numpy().flatten(), y.full().numpy().flatten(), z.full().numpy().flatten(), frame_color)
    
    return fig</code></pre>
</details>
</dd>
<dt id="tt_iga.tt_iga.Geometry.stiffness_interp"><code class="name flex">
<span>def <span class="ident">stiffness_interp</span></span>(<span>self, eps=1e-10, func=None, func_reference=None, rankinv=1024, device=None, verb=False, qtt=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to 1e-10.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>func_reference</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>rankinv</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1024.</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>verb</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
<dt><strong><code>qtt</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stiffness_interp(self, eps = 1e-10, func = None, func_reference = None, rankinv = 1024, device = None, verb = False, qtt = False):
    &#34;&#34;&#34;
    

    Args:
        eps ([type], optional): [description]. Defaults to 1e-10.
        func ([type], optional): [description]. Defaults to None.
        func_reference ([type], optional): [description]. Defaults to None.
        rankinv (int, optional): [description]. Defaults to 1024.
        device ([type], optional): [description]. Defaults to None.
        verb (bool, optional): [description]. Defaults to False.
        qtt (bool, optional): [description]. Defaults to False.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    
    p1, w1 = points_basis(self.basis[0],mult=2)
    p2, w2 = points_basis(self.basis[1],mult=2)
    p3, w3 = points_basis(self.basis[2],mult=2)
    ps = [tn.tensor(p1),tn.tensor(p2),tn.tensor(p3)]
    ws = [tn.tensor(w1), tn.tensor(w2), tn.tensor(w3)]
    
    params = [tn.tensor(b.interpolating_points()[0]) for b in self.basis[3:]]
    
    tme = datetime.datetime.now()
    Og_tt = self.eval_omega([p1,p2,p3], eps)
    tme = datetime.datetime.now() - tme
    if verb: print(&#39;time omega&#39; , tme,flush=True)

    if qtt: 
        Nqtt = qtt_shape(Og_tt, list(range(len(Og_tt.N))))
        if verb:
            print(&#39;QTT enabled:&#39;)
            print(list(Og_tt.N))
            print(&#39;  || &#39;)
            print(&#39;  \/  &#39;)
            print(Nqtt)
        No =list(Og_tt.N)
        Og_tt = tntt.reshape(Og_tt,Nqtt)     


    if not qtt:
        tme = datetime.datetime.now()
        # Ogi_tt = 1/Og_tt
        Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8,  verbose = False, preconditioner = &#39;c&#39;)
        tme = datetime.datetime.now() -tme
        if verb: print(&#39;time omega inv&#39; , tme,&#39; rank &#39;,Ogi_tt.R,flush=True)
        #if verb: print(&#39;invert error &#39;,(Ogi_tt*Og_tt-tt.ones(Og_tt.n)).norm()/tt.ones(Og_tt.n).norm())
        Ogi_tt = Ogi_tt.round(eps)
    else:
        pass
        # Ogi_tt = tntt.elementwise_divide(tntt.ones(Og_tt.N, dtype = tn.float64, device = device), Og_tt, eps = eps, starting_tensor = None, nswp = 50, kick = 8)
    

    if func != None or func_reference != None:
        tmp = tntt.meshgrid(params)
        if func_reference == None:
            X, Y, Z = self(ps, (False,False,False))
            F_tt = tntt.interpolate.function_interpolate(func, [X, Y, Z]+[tntt.ones(X.N[:3]) ** t for t in tmp], eps = eps , verbose=False).round(eps)
            
            if verb: print(&#39;rank of Frtt is &#39;,F_tt.r)
        else:
            F_tt = tntt.interpolate.function_interpolate(func_reference,tntt.meshgrid(ps+params),eps = eps,verbose = False).round(eps)
            if verb: print(&#39;rank of Ftt is &#39;,F_tt.R)
    else:
        F_tt = tntt.ones(Og_tt.N)

    if qtt:
        F_tt = tntt.reshape(F_tt,Nqtt) 
    else: 
        Ogi_tt = (Ogi_tt * F_tt).round(eps)
    
    tme = datetime.datetime.now()
    g11, g21, g31 = GTT(ps, self.basis, self.Xs, (True,False,False))
    g12, g22, g32 = GTT(ps, self.basis, self.Xs, (False,True,False))
    g13, g23, g33 = GTT(ps, self.basis, self.Xs, (False,False,True))
    if device!=None:
        g11 = g11.to(device)
        g12 = g12.to(device)
        g13 = g13.to(device)
        g21 = g21.to(device)
        g22 = g22.to(device)
        g23 = g23.to(device)
        g31 = g31.to(device)
        g32 = g32.to(device)
        g33 = g33.to(device)

    if verb:
        print(g11.R) 
        print(g12.R) 
        print(g13.R) 
        print(g21.R) 
        print(g22.R) 
        print(g23.R) 
        print(g31.R) 
        print(g32.R) 
        print(g33.R) 
    tme = datetime.datetime.now() -tme
    if verb:  print(&#39;G computed in &#39; , tme)
    
    # adjugate
    tme = datetime.datetime.now()
    h11,h12,h13 = (g22*g33-g23*g32, g13*g32-g12*g33, g12*g23-g13*g22)
    h21,h22,h23 = (g23*g31-g21*g33, g11*g33-g13*g31, g13*g21-g11*g23)
    h31,h32,h33 = (g21*g32-g22*g31, g12*g31-g11*g32, g11*g22-g12*g21)
    
    # tme = datetime.datetime.now()
    H = [[h11.round(eps),h12.round(eps),h13.round(eps)],[h21.round(eps),h22.round(eps),h23.round(eps)],[h31.round(eps),h32.round(eps),h33.round(eps)]]

    tme = datetime.datetime.now() -tme
    if verb: print(&#39;H computed in&#39; , tme)
    
    Bs = [tn.tensor(self.basis[i](ps[i]).transpose()).to(device) for i in range(3)]
    dBs = [tn.tensor(self.basis[i](ps[i],derivative = True).transpose()).to(device) for i in range(3)]
            
    N = self.Xs[0].N
    S = None
    SS = None
    Hs = dict()
    
    # the size of the bands
    band_size = [b.deg for b in self.basis[:3]]+[1]*len(N[3:])

    if qtt: 
        for i in range(3):
            for j in range(3):
                H[i][j] = tntt.reshape(H[i][j], Nqtt, eps)
                # print(H[i][j].r)

    for alpha in range(3):
        for beta in range(3):
            if verb: print(&#39;alpha, beta = &#39;,alpha,beta)
            tme = datetime.datetime.now()

            tmp = H[alpha][0]*H[beta][0]+H[alpha][1]*H[beta][1]+H[alpha][2]*H[beta][2]
            tmp = tmp.round(eps,rankinv)
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\ttime 1 &#39; , tme)


            tme = datetime.datetime.now()
            if not qtt:
                tmp = tmp*Ogi_tt
                tmp = tmp.round(eps,rankinv)
            else:
                tmp = tntt.elementwise_divide(tmp,Og_tt, starting_tensor = tmp, eps=eps,kick=8, nswp = 50, local_iterations = 20, resets = 4, preconditioner = &#39;c&#39;)*F_tt 
                # tmp = tmp*Ogi_tt*F_tt

        #  print(&#39;Rank of product&#39;,tmp.r)
            
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\ttime 2 &#39; , tme,&#39; rank &#39;,tmp.R)
            
            # print(&#39;ERR &#39;,(tmp-tmp2).norm()/tmp.norm())

            if qtt: tmp = tntt.reshape(tmp,No)
            
            # tmp = H[alpha][0]*Hi[beta][0]+H[alpha][1]*Hi[beta][1]+H[alpha][2]*Hi[beta][2]
            # tmp = tmp.round(eps,rankinv)
            
            tme = datetime.datetime.now()
            cores = tmp.cores
            
            tme = datetime.datetime.now()
            # cores[0] = np.einsum(&#39;rjs,j,jm,jn-&gt;rmns&#39;,cores[0],w1,dB1 if alpha==0 else B1,dB1 if beta==0 else B1)
            # print(cores[0].shape,w1.shape)
            for i in range(3):
                cores[i] = tn.einsum(&#39;rjs,j-&gt;rjs&#39;,cores[i],ws[i])
                tmp = tn.einsum(&#39;jm,jn-&gt;jmn&#39;,dBs[i] if alpha==i else Bs[i], dBs[i] if beta==i else Bs[i])
                cores[i] = tn.einsum(&#39;rjs,jmn-&gt;rmns&#39;,cores[i],tmp)
                
            for i in range(3,len(cores)):
                cores[i] = tn.einsum(&#39;rjs,mj,nj-&gt;rmns&#39;,cores[i],tn.eye(cores[i].shape[1],dtype=tn.float64),tn.eye(cores[i].shape[1],dtype=tn.float64))
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\t\ttime &#39; , tme)
            
            
            tme = datetime.datetime.now()
            ss = tntt.TT([tn.tensor(bandcore2ttcore(cores[i].cpu().numpy(),band_size[i])) for i in range(len(cores))]).to(device)

            
            SS = ss if SS==None else SS+ss 
            
            
            tme = datetime.datetime.now() -tme
            if verb: print(&#39;\ttime 4 &#39; , tme)
        tme = datetime.datetime.now()

        SS = SS.round(eps)
        
        tme = datetime.datetime.now() -tme
        if verb: print(&#39;\ttime ROUND &#39; , tme)
    
    cores = SS.cores
    SS = tntt.TT([tn.tensor(ttcore2bandcore(cores[i].cpu().numpy(),N[i],band_size[i])) for i in range(len(N))])

    return SS</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tt_iga" href="index.html">tt_iga</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tt_iga.tt_iga.Function" href="#tt_iga.tt_iga.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="tt_iga.tt_iga.Function.L2error" href="#tt_iga.tt_iga.Function.L2error">L2error</a></code></li>
<li><code><a title="tt_iga.tt_iga.Function.interpolate" href="#tt_iga.tt_iga.Function.interpolate">interpolate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tt_iga.tt_iga.Geometry" href="#tt_iga.tt_iga.Geometry">Geometry</a></code></h4>
<ul class="two-column">
<li><code><a title="tt_iga.tt_iga.Geometry.eval_omega" href="#tt_iga.tt_iga.Geometry.eval_omega">eval_omega</a></code></li>
<li><code><a title="tt_iga.tt_iga.Geometry.integral_tensor" href="#tt_iga.tt_iga.Geometry.integral_tensor">integral_tensor</a></code></li>
<li><code><a title="tt_iga.tt_iga.Geometry.interpolate" href="#tt_iga.tt_iga.Geometry.interpolate">interpolate</a></code></li>
<li><code><a title="tt_iga.tt_iga.Geometry.mass_interp" href="#tt_iga.tt_iga.Geometry.mass_interp">mass_interp</a></code></li>
<li><code><a title="tt_iga.tt_iga.Geometry.plot_domain" href="#tt_iga.tt_iga.Geometry.plot_domain">plot_domain</a></code></li>
<li><code><a title="tt_iga.tt_iga.Geometry.stiffness_interp" href="#tt_iga.tt_iga.Geometry.stiffness_interp">stiffness_interp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>